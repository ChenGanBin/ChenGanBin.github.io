<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知行合一</title>
  
  <subtitle>唯一的出路就是穿过苦难</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.yilinfeng.top/"/>
  <updated>2020-01-09T13:29:29.685Z</updated>
  <id>https://blog.yilinfeng.top/</id>
  
  <author>
    <name>陈淦斌</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java的foreach</title>
    <link href="https://blog.yilinfeng.top/posts/4c0b6fc5.html"/>
    <id>https://blog.yilinfeng.top/posts/4c0b6fc5.html</id>
    <published>2019-10-31T04:31:13.000Z</published>
    <updated>2020-01-09T13:29:29.685Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --><p>开发中经常使用到foreach，现在是时候深入了解一下了。</p><a id="more"></a><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>foreach是for的增强，基本语法结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的collection 指数组或集合</span></span><br><span class="line"><span class="keyword">for</span>(T t : collection) &#123;</span><br><span class="line">  ... dosomething ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 数组</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 集合</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">for</span>(String str : list) &#123;</span><br><span class="line">  System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>由上面的例子可以看到，在写法上foreach与for写法相比是简化了很多。</p><p>要注意的一点是：使用foreach能遍历的，使用for也能遍历，反之则不一定能！！！</p><p>其次还有一些缺点：</p><ul><li>对于数组，在遍历过程中需要使用元素下标的，则无能为力。</li><li>对于集合，在遍历过程中无法对元素进行增删，否则会报异常，因为我们没法获得迭代器进行操作。</li></ul><h1 id="遍历的顺序"><a href="#遍历的顺序" class="headerlink" title="遍历的顺序"></a>遍历的顺序</h1><p>有时候我们可能对元素的遍历顺序有要求，那么使用foreach与for的遍历顺序是一致的吗？</p><p>答案是一样的！！</p><p>通过阅读官方的文档可以知道，对数组使用foreach写法，等同于下面的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于集合而言，就和使用迭代器进行遍历一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator iterator = collection.iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">  iterator.next <span class="keyword">do</span> something......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="迭代器iterator"><a href="#迭代器iterator" class="headerlink" title="迭代器iterator"></a>迭代器iterator</h1><p>对于集合而言，使用foreach的遍历，其实就是在使用迭代器进行遍历，这点通过Java的规范文档可以了解到，也可以通过对Java的class文件反编译观察到，如下图所示：</p><p><img src="https://ws1.sinaimg.cn/large/e6dffef4gy1g8h9syd4fbj21bb0bqq3u.jpg" alt="foreach与迭代器.png"></p><p>但是与直接使用iterator不同，使用foreach的过程中，是无法对元素进行增删的，因为iterator是隐含的仅存在于编译后的class文件中，即开发中无法直接获取iterator，因而也就无法执行增删操作。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/81cec83541be" target="_blank" rel="noopener">Java中的foreach遍历顺序</a></p><p><a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.14.2" target="_blank" rel="noopener">Java规范文档-看14.14.2. The enhanced for statement部分</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;开发中经常使用到foreach，现在是时候深入了解一下了。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://blog.yilinfeng.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.yilinfeng.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Map的N种遍历方法</title>
    <link href="https://blog.yilinfeng.top/posts/35b60266.html"/>
    <id>https://blog.yilinfeng.top/posts/35b60266.html</id>
    <published>2019-10-30T14:26:47.000Z</published>
    <updated>2020-01-09T13:29:29.685Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --><p>开发中经常要使用到集合类Map，现在让我们来研究一下究竟有多少种遍历方法吧。</p><a id="more"></a><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>遍历map时，我们想获得啥？</p><p>键值对？键？值？</p><p>贴心的Java已经定义了如下的三种方法供我们使用：</p><ul><li>entrySet()：获取键值对集合，返回类型是Set</li><li>keySet()：获取键集合，返回类型是Set</li><li>values()：获取值集合，返回类型是Collection</li></ul><p>由上面的返回类型可以知道，我们要遍历map，其实就是要遍历Collection，常用的遍历Collection方法：</p><ul><li>增强型for</li><li>迭代器</li><li>Lambda</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"firstElement"</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">"secondElement"</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用for遍历</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">  System.out.println(<span class="string">"for-entry 键："</span> + entry.getKey() + <span class="string">", 值："</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String k : map.keySet()) &#123;</span><br><span class="line">  System.out.println(<span class="string">"for-key 键："</span> + k + <span class="string">", 值："</span> + map.get(k));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Integer v : map.values()) &#123;</span><br><span class="line">  System.out.println(<span class="string">"for-value 值："</span> + v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器遍历</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">  Map.Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">  System.out.println(<span class="string">"iterator-entry 键："</span> + entry.getKey() + <span class="string">", 值："</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; kIterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (kIterator.hasNext()) &#123;</span><br><span class="line">  String key = kIterator.next();</span><br><span class="line">  System.out.println(<span class="string">"iterator-key 键："</span> + key + <span class="string">", 值："</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; vIterator = map.values().iterator();</span><br><span class="line"><span class="keyword">while</span> (vIterator.hasNext()) &#123;</span><br><span class="line">  Integer value = vIterator.next();</span><br><span class="line">  System.out.println(<span class="string">"iterator-value 值："</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Lambda</span></span><br><span class="line">map.forEach((k, v) -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">"Lambda-entry 键："</span> + k + <span class="string">", 值："</span> + v);</span><br><span class="line">&#125;);</span><br><span class="line">map.entrySet().forEach(entry -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">"Lambda-entry 键："</span> + entry.getKey() + <span class="string">", 值："</span> + entry.getValue());</span><br><span class="line">&#125;);</span><br><span class="line">map.keySet().forEach(key -&gt; System.out.println(<span class="string">"Lambda-key 键："</span> + key + <span class="string">", 值："</span> + map.get(key)));</span><br><span class="line">map.values().forEach(value -&gt; System.out.println(<span class="string">"Lambda-value 值："</span> + value));</span><br></pre></td></tr></table></figure><h1 id="entrySet-、keySet-和values-的作用"><a href="#entrySet-、keySet-和values-的作用" class="headerlink" title="entrySet()、keySet()和values()的作用"></a>entrySet()、keySet()和values()的作用</h1><p>就像我们会遍历Collection集合一样，偶尔我们也会因业务需求遍历Map，但是Map的实现并不像Collection这么简单，底层是个数组或者链表什么的。</p><p>以HashMap为例，它的底层数据结构是：数组+链表+红黑树，这样作为开发者的我们就要花费大量精力去实现怎么遍历。</p><p>因此特意提供了entrySet()、keySet()和values()这三个方法，屏蔽底层的实现，提供简单易用的Collection。</p><h1 id="3种遍历方法的本质"><a href="#3种遍历方法的本质" class="headerlink" title="3种遍历方法的本质"></a>3种遍历方法的本质</h1><blockquote><p>迭代器模式：<strong>提供一种方法顺序的访问一个聚合对象中各个元素，而又不暴露该对象的内部表示</strong>。</p></blockquote><p>虽然上面提供了三种遍历方式，但其本质依然调用了迭代器：</p><ul><li>增强型for循环，其底层是使用了iterator，这点可以通过编译后的代码可以了解到。</li><li>使用了Lambda表达式的forEach，其方法体内部依然是使用了增强型for循环。</li></ul><p>通过使用迭代器我们就能轻易的访问集合对象而又无须关注集合对象的内部实现。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;开发中经常要使用到集合类Map，现在让我们来研究一下究竟有多少种遍历方法吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://blog.yilinfeng.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.yilinfeng.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储IP地址</title>
    <link href="https://blog.yilinfeng.top/posts/e38e4cbe.html"/>
    <id>https://blog.yilinfeng.top/posts/e38e4cbe.html</id>
    <published>2019-10-26T09:07:44.000Z</published>
    <updated>2020-01-09T13:29:29.685Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --><p>在MySQL中，没有专门用于存储IP地址的数据类型，但是可以使用inet_aton()函数把IP地址转换成整型数值进行存储，使用inet_ntoa()函数把整型数值转换回IP地址。</p><a id="more"></a><h1 id="inet-aton-和inet-ntoa-函数"><a href="#inet-aton-和inet-ntoa-函数" class="headerlink" title="inet_aton()和inet_ntoa()函数"></a>inet_aton()和inet_ntoa()函数</h1><p>inet_aton()和inet_ntoa()是MySQL提供的一对函数，一般情况下都是互相配合使用的：</p><ul><li>inet_aton()：把IP地址转换成一个整型数值，其中的aton可以理解成 IP Address-&gt;Number</li><li>inet_ntoa()：把整型数值转换成IP地址，其中的ntoa可以理解成Number-&gt;IP Address</li></ul><p>具体的流程：inet_aton(IP地址)—&gt;整型数值，inet_ntoa(整型数值)-&gt;IP地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> select inet_aton('255.255.255.255');</span><br><span class="line"><span class="meta">&gt;</span> 4294967295</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span> select inet_ntoa('4294967295');</span><br><span class="line"><span class="meta">&gt;</span> 255.255.255.255</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span> select inet_aton('0.0.0.0');  </span><br><span class="line"><span class="meta">&gt;</span> 0</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span> select inet_ntoa('0');</span><br><span class="line"><span class="meta">&gt;</span> 0.0.0.0</span><br></pre></td></tr></table></figure><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>在不知道inet_aton()和inet_ntoa()函数存在的情况下，我们会想到使用varchar解决IP地址长度不固定的存储问题。但是为了更高的性能，MySQL为我们提供了专用的函数。</p><blockquote><p>IP地址范围：0.0.0.0 - 255.255.255.255</p></blockquote><p>根据IP地址的范围，使用varchar类型，存储IP地址的最小值（0.0.0.0）要占用7个字符，存储IP地址的最大值（255.255.255.255）要占用15个字符，按照一般使用UTF-8编码计算，存储占用在<strong>22~46个字节</strong>之间。</p><p>使用inet_aton()函数，IP地址的最大值（255.255.255.255）转换后产生的整型数值为<em>4294967295</em>，即只需要一个int类型即可存储，而一个int类型数据在数据库中只占用<strong>4个字节</strong>。</p><p>通过以上的分析可以了解到，使用函数对IP地址转换后进行存储比直接存储字符串在存储空间上要节省得多，其次在运算上也有明显的优势。</p><p>注意：因为没有在真实的场景中用IP地址进行过运算，这里没法给出例子，等以后以后遇到了再回来修改！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;在MySQL中，没有专门用于存储IP地址的数据类型，但是可以使用inet_aton()函数把IP地址转换成整型数值进行存储，使用inet_ntoa()函数把整型数值转换回IP地址。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://blog.yilinfeng.top/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL开发时异常记录</title>
    <link href="https://blog.yilinfeng.top/posts/a7ec3638.html"/>
    <id>https://blog.yilinfeng.top/posts/a7ec3638.html</id>
    <published>2019-10-25T15:03:02.000Z</published>
    <updated>2020-01-09T13:29:29.685Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --><p>记录开发过程中遇到过的MySQL异常。</p><a id="more"></a><h1 id="Unknown-error-1045"><a href="#Unknown-error-1045" class="headerlink" title="Unknown error 1045"></a>Unknown error 1045</h1><p>数据库的账号密码输入错误。</p><h1 id="Data-truncation-22001"><a href="#Data-truncation-22001" class="headerlink" title="Data truncation: #22001"></a>Data truncation: #22001</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cause: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: #22001</span><br></pre></td></tr></table></figure><p>插入的数据值范围超过了字段在数据库中定义的范围。</p><h1 id="The-server-time-zone-value-‘�й���׼ʱ��’-is-unrecognized-or-represents-more-than-one-time-zone"><a href="#The-server-time-zone-value-‘�й���׼ʱ��’-is-unrecognized-or-represents-more-than-one-time-zone" class="headerlink" title="The server time zone value ‘�й���׼ʱ��’ is unrecognized or represents more than one time zone"></a>The server time zone value ‘�й���׼ʱ��’ is unrecognized or represents more than one time zone</h1><p>在较新版本的<em>mysql-connector-java</em>里，需要在连接数据库的url上加入<em>serverTimeZone</em>参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 需要注意serverTimeZone的大小写</span><br><span class="line">jdbc:mysql:<span class="comment">//localhost:3306/test?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br></pre></td></tr></table></figure><p>一般情况使用参数<em>serverTimezone=Asia/Shanghai</em>，代表中国的时区（UTC+8）</p><p>如果有多国的时差问题，直接使用<em>serverTimezone=UTC</em>，即全球标准时间</p><p>可用参数参考：<a href="https://blog.csdn.net/Shezzer/article/details/80201264" target="_blank" rel="noopener">mysql serverTimezone</a></p><h1 id="java-sql-SQLException-HY000"><a href="#java-sql-SQLException-HY000" class="headerlink" title="java.sql.SQLException: #HY000"></a>java.sql.SQLException: #HY000</h1><p>字段在数据库中定义为非空字段，但是插入数据时该字段对应的值却为空。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;记录开发过程中遇到过的MySQL异常。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://blog.yilinfeng.top/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>IDEA输出中文乱码解决方法</title>
    <link href="https://blog.yilinfeng.top/posts/3d0562c8.html"/>
    <id>https://blog.yilinfeng.top/posts/3d0562c8.html</id>
    <published>2019-10-23T13:37:47.000Z</published>
    <updated>2020-01-09T13:29:29.685Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --><p>IDEA输出中文乱码是个常见的问题了，记录下问题的解决方法，以及网上方法无效的原因。</p><a id="more"></a><p>先上结论：首先要确认是idea的问题，如果是则打开idea，选择help-&gt;Edit Custom VM Options，加入参数-Dfile.encoding=UTF-8，保存并重启，即可解决问题。</p><h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p>要解决中文乱码问题，首先要知道是哪里导致了中文乱码，才能进行针对性的配置。</p><p>定位的方法很简单，就是使用排除法：</p><ul><li>直接用<em>java -jar</em>直接运行程序</li><li>直接用构建工具运行程序</li><li>是web程序则直接用tomcat运行</li></ul><p>这样就很清楚的知道是哪里的问题了。</p><p>但是！但是！但是！一般情况下上面的环节其实都是没问题的，主要问题是在idea的身上！</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><blockquote><p>windows默认使用GBK，idea新装的时候也是使用GBK</p></blockquote><p>看到中文乱码，我们会自然的联想到是编码问题，所以会把GBK改为兼容性更好的UTF-8，具体操作如下：</p><ol><li>打开idea</li><li>选中工具栏中的<strong>Help</strong>标签下的<strong>Edit Custom VM Options</strong></li><li>加入参数 <strong>-Dfile.encoding=UTF-8</strong></li><li>保存并重启idea</li></ol><p>经过上述步骤，中文乱码就迎刃而解了。</p><h1 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h1><p>搜索引擎上能搜索到很多解决idea中文乱码的文章，都是在<strong>vmoptions</strong>中添加参数 <strong>-Dfile.encoding=UTF-8</strong>，但是就是没有效果！为啥？</p><p>其实是因为idea在用户目录下有一个<strong>vmoptions</strong>副本！！</p><p>跟着文章通常修改的是idea安装目录下的idea.exe.vmoptions和idea64.exe.vmoptions，说白点就是你修改的和idea使用的根本不是同一个，才会导修改没有效果。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/sxdcgaq8080/p/7648400.html" target="_blank" rel="noopener">重点在评论14楼</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;IDEA输出中文乱码是个常见的问题了，记录下问题的解决方法，以及网上方法无效的原因。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://blog.yilinfeng.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="常见问题" scheme="https://blog.yilinfeng.top/categories/%E5%B7%A5%E5%85%B7/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>深入操作系统-01环境创建</title>
    <link href="https://blog.yilinfeng.top/posts/d1f7f56f.html"/>
    <id>https://blog.yilinfeng.top/posts/d1f7f56f.html</id>
    <published>2019-10-10T13:29:20.000Z</published>
    <updated>2020-01-09T13:29:29.685Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --><p>要开发一个操作系统，搭建开发环境是必不可少的，本篇文章就介绍如何使用Linux、bochs搭建开发环境。</p><a id="more"></a><p>注意：本文章还没有涉及到C语言，所以环境搭建没有涉及到这部分，将会在后续进行补充。</p><h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>在不考虑其它的情况下，先要知道一个OS源码最后要怎么在机器上运行。</p><ol><li>编写一个汇编源码文件（a.asm）</li><li>使用nasm把汇编文件a.asm编译成二进制文件a.bin</li><li>把二进制文件a.bin写入到磁盘中（在开发环境中即a.img）</li><li>在bochs使用已写入汇编源码的磁盘（a.img）进行测试运行</li></ol><p>即源码文件经历了如下流程：.asm -&gt; a.bin -&gt; a.img</p><p>现在已经整个开发流程有了一个基本的认知了，下面逐一讲解需要用到的工具。</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>是基本的编译环境，其次把编译好的二进制文件写入到磁盘中也需要用到Linux中的指令，即源码的编译与文件的写入都离开不了Linux。</p><h1 id="Nasm"><a href="#Nasm" class="headerlink" title="Nasm"></a>Nasm</h1><p>是一个汇编指令的编译软件，能把汇编文件编译成二进制文件。</p><h1 id="Bochs"><a href="#Bochs" class="headerlink" title="Bochs"></a>Bochs</h1><p>已经写好的程序该放到哪里运行呢？放到自己的电脑上，程序有故障怎么办！所以最好的办法是使用虚拟机，可以随便折腾，有问题也不怕，但是我们需要调试程序，所以使用普通的虚拟机也不行。</p><p>因此使用bochs就是一个极好的选择，既是虚拟机又带有调试功能。</p><p>在这里省略bochs的安装过程，主要看看使用bochs时需要用到的配置文件（注意：文件后缀是bxrc的就是bochs用到的配置文件，例：bochsrc.bxrc）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 为虚拟机分配的内存（RAM）大小，默认单位是MB</span><br><span class="line">megs: 32</span><br><span class="line"></span><br><span class="line"># 这里还没研究</span><br><span class="line">romimage: file=$BXSHARE/BIOS-bochs-latest</span><br><span class="line">vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line"># 使用的磁盘列表</span><br><span class="line">floppya: 1_44=boot.img, status=inserted</span><br><span class="line"></span><br><span class="line"># 选择引导磁盘 cdroom即光驱 floppy即软驱 disk即硬盘</span><br><span class="line">boot: floppy</span><br><span class="line"></span><br><span class="line"># 输出的日志文件</span><br><span class="line">log: bochsout.txt</span><br><span class="line"></span><br><span class="line"># 是否启用鼠标</span><br><span class="line">mouse: enabled=0</span><br><span class="line"></span><br><span class="line"># 键盘布局</span><br><span class="line">keyboard: keymap=$BXSHARE/keymaps/x11-pc-us.map</span><br></pre></td></tr></table></figure><p>注意：上文中提到的$BXSHARE即为bochs的安装目录。</p><p>通过配置文件可以知道，要运行我们自己写的操作系统，只需要在配置文件中的磁盘列表加入我们创建的磁盘，并在以到磁盘项中选择我们的磁盘，然后运行bochs即可。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上便是开发一个操作系统需要的基本开发环境，目前涉及到的C语言部分将在后面完善。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;要开发一个操作系统，搭建开发环境是必不可少的，本篇文章就介绍如何使用Linux、bochs搭建开发环境。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://blog.yilinfeng.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://blog.yilinfeng.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>科学的重复</title>
    <link href="https://blog.yilinfeng.top/posts/ab6871d9.html"/>
    <id>https://blog.yilinfeng.top/posts/ab6871d9.html</id>
    <published>2019-06-24T15:06:19.000Z</published>
    <updated>2020-01-09T13:29:29.685Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --><p>想要学习效果好，记忆是个绕不开的话题，通过科学的重复记忆，就能显著的提高记忆效果。</p><a id="more"></a><h1 id="遗忘曲线"><a href="#遗忘曲线" class="headerlink" title="遗忘曲线"></a>遗忘曲线</h1><blockquote><p>遗忘曲线（又名：艾宾浩斯遗忘曲线）揭示了人类大脑对于新事物的记忆规律：遗忘是先快后慢，最有趋于稳定。</p></blockquote><h1 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h1><p>根据遗忘曲线的特性，在关键时间点上进行重复复习，即可事半功倍的进行记忆。</p><p>关键时间点：一般记住后，在5分钟后重复一遍，30分钟后再重复一遍，12小时后，1天后，2天后，4天后，7天后，15天后就会记得很牢。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>并不需要一定要严格按照上述的时间点进行复习，只需要在大概的时间重复记忆一下内容即可，其本质是：重复记忆。</p><p>计划在后续中进行尝试，并记录下心得。</p><p>记录于2019-06-24 23：04，开始尝试。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://baike.baidu.com/item/%E9%81%97%E5%BF%98%E6%9B%B2%E7%BA%BF/7278665?fromtitle=%E8%89%BE%E5%AE%BE%E6%B5%A9%E6%96%AF%E9%81%97%E5%BF%98%E6%9B%B2%E7%BA%BF&amp;fromid=3905802" target="_blank" rel="noopener">艾宾浩斯遗忘曲线</a></p><p><a href="https://www.zhihu.com/question/31136262" target="_blank" rel="noopener">如何利用遗忘曲线来有效记忆？</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;想要学习效果好，记忆是个绕不开的话题，通过科学的重复记忆，就能显著的提高记忆效果。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://blog.yilinfeng.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="记忆" scheme="https://blog.yilinfeng.top/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%B0%E5%BF%86/"/>
    
    
      <category term="学习" scheme="https://blog.yilinfeng.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="记忆" scheme="https://blog.yilinfeng.top/tags/%E8%AE%B0%E5%BF%86/"/>
    
  </entry>
  
  <entry>
    <title>架构师的思考层次</title>
    <link href="https://blog.yilinfeng.top/posts/b1bd9b76.html"/>
    <id>https://blog.yilinfeng.top/posts/b1bd9b76.html</id>
    <published>2019-06-24T14:33:08.000Z</published>
    <updated>2020-01-09T13:29:29.685Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --><p>作为一个架构师，在面对一个产品的时候应该怎么进行思考呢？</p><a id="more"></a><h1 id="关注产品本身"><a href="#关注产品本身" class="headerlink" title="关注产品本身"></a>关注产品本身</h1><p>第一个层次是<strong>关注产品本身</strong>，即只会考虑产品本身系统的事情，不会考虑系统外的事情，例：后期与第三方系统对接的问题等。</p><h1 id="关注整个系统"><a href="#关注整个系统" class="headerlink" title="关注整个系统"></a>关注整个系统</h1><p>第二个层次是<strong>关注整个系统</strong>，在上了规模的产品中，大多是多个系统之间的配合，因此除了要关注自己的系统之外，还要考虑到与其它系统之间的协作。</p><h1 id="关注产品背后的价值"><a href="#关注产品背后的价值" class="headerlink" title="关注产品背后的价值"></a>关注产品背后的价值</h1><p>第三个层次是<strong>关注产品可能潜在的价值</strong>，除了技术的要素，重点关注的是价值，即该产品可能带来的价值。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上内容是阅读别人文章后的心得，并计划在后续的工作中进行尝试，记录于2019-06-24 22：30。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.51cto.com/frankfan/1248401" target="_blank" rel="noopener">架构设计师—你在哪层楼？</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;作为一个架构师，在面对一个产品的时候应该怎么进行思考呢？&lt;/p&gt;
    
    </summary>
    
      <category term="架构师" scheme="https://blog.yilinfeng.top/categories/%E6%9E%B6%E6%9E%84%E5%B8%88/"/>
    
    
      <category term="架构师" scheme="https://blog.yilinfeng.top/tags/%E6%9E%B6%E6%9E%84%E5%B8%88/"/>
    
  </entry>
  
  <entry>
    <title>斐讯N1刷机后操作</title>
    <link href="https://blog.yilinfeng.top/posts/b9577586.html"/>
    <id>https://blog.yilinfeng.top/posts/b9577586.html</id>
    <published>2019-06-22T07:43:04.000Z</published>
    <updated>2020-01-09T13:29:29.685Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --><p>N1刷机成功后，为了方便使用，免不了要执行一些常见的配置操作或软件安装，例：更换国内软件源、安装docker、设置WIFI、安装Java环境等。</p><a id="more"></a><h1 id="阅读须知"><a href="#阅读须知" class="headerlink" title="阅读须知"></a>阅读须知</h1><p>本示例系统使用的是armbian 5.67 stretch 4.19</p><h1 id="设置WiFi"><a href="#设置WiFi" class="headerlink" title="设置WiFi"></a>设置WiFi</h1><p>要设置WiFi可以使用系统自带的网络设置图形界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmtui</span><br></pre></td></tr></table></figure><p>执行命令后，通过方向键和回车键选中其中的<em>Activate a connection</em>选项，将会弹出一个列表（<em>Wired</em>代表的是有线连接，<em>WiFi</em>代表的是无线连接），按提示输入WiFi账号密码即可。</p><p>如果图形界面中没有WiFi列表则说明系统的WiFi模块有问题，可按如下方法解决：</p><p>方法一： 执行如下命令重新加载模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modprobe dhd &amp;&amp; echo dhd &gt;&gt; /etc/modules</span><br><span class="line">modprobe wifi_dummy &amp;&amp; echo wifi_dummy &gt;&gt; /etc/modules</span><br></pre></td></tr></table></figure><p>方法二：使用armbian-config命令设置wifi</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 执行命令</span><br><span class="line">armbian-config</span><br></pre></td></tr></table></figure><p>依据提示选中Network中的WIFI</p><p>方法三：重新安装系统。</p><h1 id="更换国内源"><a href="#更换国内源" class="headerlink" title="更换国内源"></a>更换国内源</h1><p>重要的事情说三遍</p><p>如果默认源的安装速度不是特别慢的话，无需特意跟换源！！！</p><p>如果默认源的安装速度不是特别慢的话，无需特意跟换源！！！</p><p>如果默认源的安装速度不是特别慢的话，无需特意跟换源！！！</p><p>/etc/apt/sources.list文件记录的是系统所使用的软件源，而默认安装的系统使用的是国外源</p><p>首先对/etc/apt/sources.list文件进行备份，以备不时之需</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><p>然后编辑/etc/apt/sources.list文件，把原有的源删除，并加入新的国内源（这里使用的是科大的源，如果需要的可以自行更换为其它源，如：163、清华等），并保存。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"># 科大软件源</span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian/ stretch main non-free contrib</span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian/ stretch-updates main non-free contrib</span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian/ stretch-backports main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/debian/ stretch main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/debian/ stretch-updates main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/debian/ stretch-backports main non-free contrib</span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian-security/ stretch/updates main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/debian-security/ stretch/updates main non-free contrib</span><br></pre></td></tr></table></figure><p></p><p>最后执行更新命令，使软件列表生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br></pre></td></tr></table></figure><p>等待命令执行完，至此新的软件源就生效了。</p><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p>安装docker有一个非常便捷的方法就是使用阿里提供的一键安装脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><p>通过脚本直接安装docker及其所需的依赖，可以说是非常方便了。</p><p>注意：该脚本会直接安装最新的docker脚本</p><h1 id="安装JRE"><a href="#安装JRE" class="headerlink" title="安装JRE"></a>安装JRE</h1><p>有时候需要运行Java程序，因此JRE（Java运行时环境）是必不可少的。</p><p>执行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装java8的jre</span><br><span class="line">apt-get install openjdk-8-jre</span><br></pre></td></tr></table></figure><p>注意点一：如果安装过程中遇到所需依赖无法下载的问题，可能是由apt源造成的。博主之前使用的是科大软件源，结果提示部分依赖缺少无法下载，然后跟换回默认源就可以了。</p><p>注意点二：博主一开始是从Oracle官网下载的解压包：server-jre-8u212-linux-x64.tar.gz，并用其配置环境，但是在尝试执行命令的时候却报错：<em>cannot execute binary file: Exec format error</em>，这是因为该解压包的文件目标运行系统和本系统（参考：阅读须知）有差异而导致的，需要指定的版本才能在本系统运行。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://luotianyi.vc/1389.html" target="_blank" rel="noopener">Armbian系统重新加载WiFi模块</a></p><p><a href="https://www.hostloc.com/thread-527652-1-1.html" target="_blank" rel="noopener">N1求教连接wifi问题，实在不知道咋回事了</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;N1刷机成功后，为了方便使用，免不了要执行一些常见的配置操作或软件安装，例：更换国内软件源、安装docker、设置WIFI、安装Java环境等。&lt;/p&gt;
    
    </summary>
    
      <category term="有趣" scheme="https://blog.yilinfeng.top/categories/%E6%9C%89%E8%B6%A3/"/>
    
      <category term="刷机" scheme="https://blog.yilinfeng.top/categories/%E6%9C%89%E8%B6%A3/%E5%88%B7%E6%9C%BA/"/>
    
    
      <category term="有趣" scheme="https://blog.yilinfeng.top/tags/%E6%9C%89%E8%B6%A3/"/>
    
  </entry>
  
  <entry>
    <title>圆周率的来历</title>
    <link href="https://blog.yilinfeng.top/posts/5d007e64.html"/>
    <id>https://blog.yilinfeng.top/posts/5d007e64.html</id>
    <published>2019-05-07T12:31:00.000Z</published>
    <updated>2020-01-09T13:29:29.685Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --><p>圆周率是通过实际<strong>测量</strong>得出的，即<strong>一个圆的周长和其直径的比率</strong>。</p><a id="more"></a><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>不知道是学了忘记，还是说从来就不知道，今天才发现，所以特意记下圆周率是怎么来的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zh.wikipedia.org/wiki/%E5%9C%93%E5%91%A8%E7%8E%87" target="_blank" rel="noopener">维基百科：圆周率</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;圆周率是通过实际&lt;strong&gt;测量&lt;/strong&gt;得出的，即&lt;strong&gt;一个圆的周长和其直径的比率&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="https://blog.yilinfeng.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="https://blog.yilinfeng.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java常用名词</title>
    <link href="https://blog.yilinfeng.top/posts/b0269417.html"/>
    <id>https://blog.yilinfeng.top/posts/b0269417.html</id>
    <published>2019-04-09T08:31:43.000Z</published>
    <updated>2020-01-09T13:29:29.685Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --><p>接触Java开发已经很长一段时间了，对于常见的名词，如：JMS、JDBC、JPA，也基本知道代表的是什么，而JNDI、JTA这些就不知道了，今天特意做个备忘录，记录下在Java中遇到的这些名词，并在后续中不断更新。</p><a id="more"></a><div class="table-container"><table><thead><tr><th style="text-align:center">名词</th><th style="text-align:center">全称</th><th style="text-align:center">中文</th></tr></thead><tbody><tr><td style="text-align:center">JDBC</td><td style="text-align:center">Java DataBase Connectivity</td><td style="text-align:center">Java数据库连接</td></tr><tr><td style="text-align:center">JPA</td><td style="text-align:center">Java Persistence API</td><td style="text-align:center">Java持久化API</td></tr><tr><td style="text-align:center">JTA</td><td style="text-align:center">Java Transaction API</td><td style="text-align:center">Java事务API</td></tr><tr><td style="text-align:center">JMS</td><td style="text-align:center">Java Message Service</td><td style="text-align:center">Java消息服务</td></tr><tr><td style="text-align:center">JNDI</td><td style="text-align:center">Java Naming and Directory Interface</td><td style="text-align:center">Java命名和目录接口</td></tr><tr><td style="text-align:center">POJO</td><td style="text-align:center">Plain Ordinary Java Object</td><td style="text-align:center">简单Java对象</td></tr></tbody></table></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;接触Java开发已经很长一段时间了，对于常见的名词，如：JMS、JDBC、JPA，也基本知道代表的是什么，而JNDI、JTA这些就不知道了，今天特意做个备忘录，记录下在Java中遇到的这些名词，并在后续中不断更新。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://blog.yilinfeng.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.yilinfeng.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>博客之2019</title>
    <link href="https://blog.yilinfeng.top/posts/87daa986.html"/>
    <id>https://blog.yilinfeng.top/posts/87daa986.html</id>
    <published>2019-03-17T14:22:03.000Z</published>
    <updated>2020-01-09T13:29:29.685Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --><p>2019年的第三个月即将过去了，现在才写这篇文章好像迟了一点，不过种一棵树最好的时间是十年前，其次是现在，这样子安慰自己的话，好像还不算晚。</p><p>在2018年里仅仅写了几篇文章，不过幸运的是因为有个博客，所以总想着弄点什么来写写，从而养成了写文档的习惯，遇到不懂的、特别的都有记录下来，期望在后面的时间里写到博客上。</p><p>在前段时间，突然萌生了换个博客的想法，wordpress、typecho、hugo这些都研究了一圈，感觉就像换了一个博客所有的事情都将变得会不一样似的，就像2018年里的目标并没有达成，反而是东学学西学学但并没有实质性的进展。</p><p>最后的最后，其实自己需要的是一点坚持——对目标的坚持，也是对适合自己的学习方法的一个概括：坚持！每天运动一下、学习一下、记录一下，明天就会有那么一点不一样！</p><p>题外话：最后还是没忍住折腾劲，对博客进行了修改，当然博客程序还是那个，但是配置上做了很多修改，对以前的文章的结构、分类、命名、内容这些也不大满意，所以也进行了修改。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;2019年的第三个月即将过去了，现在才写这篇文章好像迟了一点，不过种一棵树最好的时间是十年前，其次是现在，这样
      
    
    </summary>
    
      <category term="日志" scheme="https://blog.yilinfeng.top/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="日志" scheme="https://blog.yilinfeng.top/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Conda</title>
    <link href="https://blog.yilinfeng.top/posts/c3592b96.html"/>
    <id>https://blog.yilinfeng.top/posts/c3592b96.html</id>
    <published>2018-05-20T02:34:06.000Z</published>
    <updated>2020-01-09T13:29:29.685Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --><p>Conda是一个包管理、依赖管理和<em>环境管理</em>工具，虽然由Python程序创建，但它可以打包并分发任何语言的软件，例如：Python, R, Ruby, Lua, Scala, Java, JavaScript, C/ C++, FORTRAN。</p><a id="more"></a><h1 id="Conda简介"><a href="#Conda简介" class="headerlink" title="Conda简介"></a>Conda简介</h1><blockquote><p>Conda是一个开源的包管理、依赖管理和环境管理工具，能运行在Windows、macOS和Linux上，具备快速安装、运行和更新包和依赖的能力，能够轻松的创建、保存、加载和切换不同的开发环境。虽然Conda由Python程序创建，但它可以打包并分发任何语言的软件。</p></blockquote><p>通过以上摘录自官网的译文可以知道，Conda对于经常要切换不同的开发环境的开发者来说，是一个极其合适的工具。</p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>Conda作为一个管理工具，有两个常见的发行版本：Anaconda和Miniconda，其区别如下：</p><p>Miniconda：仅仅拥有python，conda和一些必须的依赖包,除此之外没有任何附带的东西，操作时需要使用命令行的方式进行操作，占用极小的硬盘空间，但使用的时候需要自己安装所需要的包。<a href="https://conda.io/miniconda.html" target="_blank" rel="noopener">&gt;&gt;&gt;下载&lt;&lt;&lt;</a></p><p>Anaconda：拥有Miniconda所拥有的之外，还自带超过720个的开源包，并且具有图形化的操作界面，安装后即可使用，但占用较大的空间，以及会安装一些自己使用不到的包。<a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">&gt;&gt;&gt;下载&lt;&lt;&lt;</a></p><p>综上来看：两个发行版该有的基本功能一样不缺，但相对而言，Miniconda更适合一些简约的人使用，如果需要省心的话Anaconda就是一个极好的选择，毕竟多占的一些硬盘空间对现在的硬盘来说不算什么，读者可以根据自身情况进行选择。</p><p>博主比较喜欢简约因此使用的是Miniconda，同时为了更好的熟悉conda，下面将会直接使用命令行来进行操作演示。</p><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>在安装conda的过程中，其中有一个选项就是把conda加入系统环境变量中，官方提示是不建议勾选，因为重装之类的可能会导致找不到相应目录之类的，建议直接使用官方提供的命令行工具，在命令行下找到一个名为<em>Anaconda Prompt</em>的应用，如下所示：<br><img src="https://ws1.sinaimg.cn/large/e6dffef4gy1g5ppvqnx28j206w016aa2.jpg" alt="Anaconda Prompt"><br>运行后的效果如下所示：<br><img src="https://ws1.sinaimg.cn/large/e6dffef4gy1g5ppw9j5u6j20p50c2aa8.jpg" alt="Anaconda Prompt CMD"><br>但是经过一段时间的使用后发现还是加入到系统的环境变量中更方便，这样就可以随时随地在任何环境中使用了，如果已经安装了程序但又没有加入系统环境变量的，可以按照如下步骤重新加入：</p><ol><li>找到程序的安装根目录，要是安装时没有指定安装目录的话，一般都是安装在安装时使用的用户的用户目录之下，这里假设路径是conda_rootdir<br><img src="https://ws1.sinaimg.cn/large/e6dffef4gy1g5ppwjwa75j20pk0gy0uf.jpg" alt="conda安装根目录"></li><li>打开系统环境变量的设置窗口：我的电脑点击鼠标右键-&gt;属性-&gt;高级系统设置-&gt;环境变量<br><img src="https://ws1.sinaimg.cn/large/e6dffef4gy1g5ppwvx4znj211u0i8b1e.jpg" alt="系统环境变量"></li><li>在系统变量部分，找到变量名为Path的条目，选中并点击下方的编辑按钮，就能打开编辑界面<br><img src="https://ws1.sinaimg.cn/large/e6dffef4gy1g5ppx5njzxj20q00imdh7.jpg" alt="系统环境变量编辑窗口"></li><li>把如下的路径添加到系统环境变量中，记得把conda_rootdir替换为自己电脑下conda的安装根目录<br><img src="https://ws1.sinaimg.cn/large/e6dffef4gy1g5ppxihyuxj20bc034mx0.jpg" alt="conda路径"></li><li>点击确定，保存编辑的内容，然后重新打开命令行窗口，然后输入命令<em>conda info</em>，并显示相应内容的话，就表示配置成功，配置失败的请重新配置<br><img src="https://ws1.sinaimg.cn/large/e6dffef4gy1g5ppxqdloaj20rl0e5t95.jpg" alt="conda信息"></li></ol><h1 id="conda配置文件"><a href="#conda配置文件" class="headerlink" title="conda配置文件"></a>conda配置文件</h1><p>conda安装后会在用户目录下生成一个配置文件<em>.condarc</em>，如果没有的话可以自己创建一个，内容如下：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">channels:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">defaults</span></span><br></pre></td></tr></table></figure><p></p><p>配置文件中的channels属性指的是安装时的下载来源，defaults指的是默认的下载来源，如果想添加下载源的话只要按照格式添加就可以了。默认源在国内下载速度较慢，所以国内有清华镜像源即<a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/" target="_blank" rel="noopener">Anaconda 镜像</a>，使用后速度会有明显的提升，但是在这里依然不建议使用国内的清华源，因为使用一段时间后发现清华源的版本比较旧而且还不全，直接使用默认源的话使用上是基本没有问题，下载时间也就相对清华源慢一些而已。</p><p>默认情况下环境文件以及下载下来的包都是安装在软件根目录下的envs和pkgs文件夹下，如果想要更改安装路径的话，可以加入如下配置<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 环境目录</span></span><br><span class="line"><span class="attr">envs_dirs:</span></span><br><span class="line"><span class="attr">  - E:</span><span class="string">\Documents\Code\alpha\conda\envs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 包目录</span></span><br><span class="line"><span class="attr">pkgs_dirs:</span></span><br><span class="line"><span class="attr">  - E:</span><span class="string">\Documents\Code\alpha\conda\pkgs</span></span><br></pre></td></tr></table></figure><p></p><p>如果有想了解更多的可以直接访问官网了解详细的配置<a href="https://conda.io/docs/user-guide/configuration/use-condarc.html" target="_blank" rel="noopener">&gt;&gt;&gt;传送门&lt;&lt;&lt;</a></p><h1 id="Conda信息"><a href="#Conda信息" class="headerlink" title="Conda信息"></a>Conda信息</h1><p>如果想要查看Conda的信息的话，可以输入如下命令<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info</span><br></pre></td></tr></table></figure><p></p><p><img src="https://ws1.sinaimg.cn/large/e6dffef4gy1g5ppxqdloaj20rl0e5t95.jpg" alt="conda信息"><br>可以看到上一部分的配置信息也出现在内容展示中，说明配置是有效的。</p><p>如果想要查看已有的开发环境，输入如下命令<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --env</span><br></pre></td></tr></table></figure><p></p><p><img src="https://ws1.sinaimg.cn/large/e6dffef4gy1g5ppybug74j20fx02kt8i.jpg" alt="conda环境信息"><br>可以看到里面现在有两个环境，分别是base和tensorflow，其中base就是安装时默认的环境，而tensorflow就是博主自己创建的环境。</p><p>在上述图片中还有个要注意的地方就是base环境前面是有个*号的，说明base环境处于激活的状态，即判断当前所处环境的方法就是查看*号出现在那个环境前。<br><img src="https://ws1.sinaimg.cn/large/e6dffef4gy1g5ppyn28j4j20g303q0sm.jpg" alt="激活了tensorflow环境"><br>而上面这张则是激活了tensorflow环境的，而这张还有一个特别地方就是前面直接写着名为tensorflow的环境名称，因此也可以作为当前处于那个激活环境的判断。</p><p>那么到底怎么创建一个新的环境呢？</p><h1 id="环境创建、克隆、激活和删除"><a href="#环境创建、克隆、激活和删除" class="headerlink" title="环境创建、克隆、激活和删除"></a>环境创建、克隆、激活和删除</h1><p>想要创建环境，只要输入如下命令：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 不指定python版本</span><br><span class="line">conda create --name env-name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 指定python版本</span><br><span class="line">conda create --name env-name python=2.7</span><br></pre></td></tr></table></figure><p></p><p>其中env-name是该新建环境的名称；python是该环境中的python版本，默认情况下如果不写该参数，将会延用base环境中的python版本，而base环境中的python版本就是下载部分选择conda安装包时的python版本。<br><img src="https://ws1.sinaimg.cn/large/e6dffef4gy1g5ppyx53v9j20qp05gwec.jpg" alt="conda创建环境"><br>创建成功后就能看到如上的显示，想要激活环境，输入：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate env-name</span><br></pre></td></tr></table></figure><p></p><p>想要取消激活，输入：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p></p><p>当然，也可以直接关闭命令窗口来退出已激活的环境。</p><p>注意：在没有激活任何环境的情况下都是处于base环境之下的，就算激活了其它环境也只在激活的命令窗口下是激活环境，在激活环境下的任何操作，都不会对其它环境产生影响，当然这也就是conda的意义所在。</p><p>在某些情况下如果想要复制已有的环境，可以输入：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name new-env-name --clone env-name</span><br></pre></td></tr></table></figure><p></p><p>如果想删除现有的环境，必须在先取消激活目标环境，然后执行如下命令：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove --name env-name --all</span><br></pre></td></tr></table></figure><p></p><h1 id="包的查看、搜索、安装、更新和卸载"><a href="#包的查看、搜索、安装、更新和卸载" class="headerlink" title="包的查看、搜索、安装、更新和卸载"></a>包的查看、搜索、安装、更新和卸载</h1><p>注意：以下的一切命令请先激活环境后再执行，否则都将会作用于基本环境，即操作的对象是基本环境。</p><p>创建好环境后，想要使用当然还需要安装自己所需要的包，这里使用tensorflow做例子，输入如下命令，查看当前已安装的包：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure><p></p><p><img src="https://ws1.sinaimg.cn/large/e6dffef4gy1g5ppz5ky2sj20hn08mq2y.jpg" alt="查看已安装的包"></p><p>搜索可用的包<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda search tensorflow</span><br></pre></td></tr></table></figure><p></p><p><img src="https://ws1.sinaimg.cn/large/e6dffef4gy1g5ppzem086j20e804xq2t.jpg" alt="搜索可用的包"></p><p>安装包<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install tensorflow</span><br></pre></td></tr></table></figure><p></p><p>更新包<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update tensorflow</span><br></pre></td></tr></table></figure><p></p><p>卸载已安装的包<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda uninstall tensorflow</span><br></pre></td></tr></table></figure><p></p><h1 id="环境配置的导入和导出"><a href="#环境配置的导入和导出" class="headerlink" title="环境配置的导入和导出"></a>环境配置的导入和导出</h1><p>在某些情况下，如果想要分享自己的开发环境，可以通过导出目标环境的环境配置来完成分享。<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda activate tensorflow</span><br><span class="line"></span><br><span class="line">conda env export &gt; path-to/environment.yml</span><br></pre></td></tr></table></figure><p></p><p>注意：要先激活想要的分享目标环境，然后再执行导出命令</p><p>导出命令的path-to是指定目标路径，environment.yml则是导出的环境配置文件，如果不写路径则将会导出到命令行当前的路径之下。</p><p>别人拿到了你分享出来的环境配置文件又该如何使用呢，输入：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env create -f path-to/environment.yml</span><br></pre></td></tr></table></figure><p></p><p>即可创建一个和环境配置文件描述的一摸一样的开发环境了。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>至此，conda的基本用法已经讲述完，如过想要更深入了解的话可以在官网上查阅更详细的资料。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://conda.io/docs/index.html" target="_blank" rel="noopener">conda官网</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;Conda是一个包管理、依赖管理和&lt;em&gt;环境管理&lt;/em&gt;工具，虽然由Python程序创建，但它可以打包并分发任何语言的软件，例如：Python, R, Ruby, Lua, Scala, Java, JavaScript, C/ C++, FORTRAN。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://blog.yilinfeng.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>博客之始</title>
    <link href="https://blog.yilinfeng.top/posts/40124174.html"/>
    <id>https://blog.yilinfeng.top/posts/40124174.html</id>
    <published>2018-02-15T16:00:00.000Z</published>
    <updated>2020-01-09T13:29:29.685Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --><p>以前总是看别人写的博客，用OneNote做的笔记，当面试的时候被问到：你有写博客吗？我的回答是NO！ 那时候以为写博客离自己很遥远，觉得自己的水平低写不出什么东西来，但是现在仔细想想，不正是因为自己的水平低才更要写博客吗！</p><p>通过写博客来做笔记并且加入自己的思考，摆脱以前一贯的只记忆不思考的习惯，一次又一次地修改完善，才能更好的提高自己的能力。</p><p>在这特殊的一天，踏出新的一步，祝2018年大家越来越好！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jan 09 2020 13:29:47 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;以前总是看别人写的博客，用OneNote做的笔记，当面试的时候被问到：你有写博客吗？我的回答是NO！ 那时候以
      
    
    </summary>
    
      <category term="日志" scheme="https://blog.yilinfeng.top/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="日志" scheme="https://blog.yilinfeng.top/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
</feed>
