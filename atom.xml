<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知行合一</title>
  
  <subtitle>对技术的热情让我永不停歇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.yilinfeng.top/"/>
  <updated>2019-03-10T05:19:27.031Z</updated>
  <id>http://blog.yilinfeng.top/</id>
  
  <author>
    <name>陈随想</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>易经基础01-爻</title>
    <link href="http://blog.yilinfeng.top/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E5%9F%BA%E7%A1%8001-%E7%88%BB.html"/>
    <id>http://blog.yilinfeng.top/易经/易经基础01-爻.html</id>
    <published>2019-02-26T15:12:15.000Z</published>
    <updated>2019-03-10T05:19:27.031Z</updated>
    
    <content type="html"><![CDATA[<p>第一篇，了解的是爻。</p><a id="more"></a><h1 id="读法"><a href="#读法" class="headerlink" title="读法"></a>读法</h1><p>爻，读音：<strong>[yáo]</strong></p><h1 id="爻分阴阳"><a href="#爻分阴阳" class="headerlink" title="爻分阴阳"></a>爻分阴阳</h1><p>在易经中，每一卦都是由若干个“——”和“—”组成，“——”和“—”即为易经中的爻，爻又分为阴爻和阳爻</p><div class="table-container"><table><thead><tr><th style="text-align:center">爻</th><th style="text-align:center">符号</th></tr></thead><tbody><tr><td style="text-align:center">阳爻</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">阴爻</td><td style="text-align:center">—</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一篇，了解的是爻。&lt;/p&gt;
    
    </summary>
    
      <category term="神秘国学" scheme="http://blog.yilinfeng.top/categories/%E7%A5%9E%E7%A7%98%E5%9B%BD%E5%AD%A6/"/>
    
      <category term="周易" scheme="http://blog.yilinfeng.top/categories/%E7%A5%9E%E7%A7%98%E5%9B%BD%E5%AD%A6/%E5%91%A8%E6%98%93/"/>
    
    
      <category term="周易" scheme="http://blog.yilinfeng.top/tags/%E5%91%A8%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>易经基础00-前言</title>
    <link href="http://blog.yilinfeng.top/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E5%9F%BA%E7%A1%8000-%E5%89%8D%E8%A8%80.html"/>
    <id>http://blog.yilinfeng.top/易经/易经基础00-前言.html</id>
    <published>2019-02-26T15:11:49.000Z</published>
    <updated>2019-03-10T05:19:27.031Z</updated>
    
    <content type="html"><![CDATA[<p>在该系列中，将会讲解学习易经中要使用的基本概念，并在该系列的前言中汇聚成目录索引。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本系列是根据个人自学时，整理出来的一些要点，希望能帮到同为想要学习易经的初学者。</p><h1 id="系列目录"><a href="#系列目录" class="headerlink" title="系列目录"></a>系列目录</h1><ol><li></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在该系列中，将会讲解学习易经中要使用的基本概念，并在该系列的前言中汇聚成目录索引。&lt;/p&gt;
    
    </summary>
    
      <category term="神秘国学" scheme="http://blog.yilinfeng.top/categories/%E7%A5%9E%E7%A7%98%E5%9B%BD%E5%AD%A6/"/>
    
      <category term="周易" scheme="http://blog.yilinfeng.top/categories/%E7%A5%9E%E7%A7%98%E5%9B%BD%E5%AD%A6/%E5%91%A8%E6%98%93/"/>
    
    
      <category term="周易" scheme="http://blog.yilinfeng.top/tags/%E5%91%A8%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>2018-11-21 学习日记</title>
    <link href="http://blog.yilinfeng.top/%E6%97%A5%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/20181121%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0.html"/>
    <id>http://blog.yilinfeng.top/日记/学习日记/20181121学习日记.html</id>
    <published>2018-11-21T15:18:05.000Z</published>
    <updated>2019-03-10T05:19:27.031Z</updated>
    
    <content type="html"><![CDATA[<p>2018-11-21 学习日记</p><a id="more"></a><p>距离上一次写日记隔了10几天，但唯一比较安慰的是早上学习设计模式没有中断过，现在终于学习了一半了。</p><p>现在在学ehcache，学完还有mencache和redis等着呢，距离第一阶段的目标还有一般呀，比预想中要慢不少。</p><p>坚持很重要呀，不积跬步，无以至千里，大概就是真实写照了。</p><p>坚持！明天继续！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018-11-21 学习日记&lt;/p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://blog.yilinfeng.top/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="日记" scheme="http://blog.yilinfeng.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2018-11-08 学习日记</title>
    <link href="http://blog.yilinfeng.top/%E6%97%A5%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/20181108%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0.html"/>
    <id>http://blog.yilinfeng.top/日记/学习日记/20181108学习日记.html</id>
    <published>2018-11-08T15:21:12.000Z</published>
    <updated>2019-03-10T05:19:27.031Z</updated>
    
    <content type="html"><![CDATA[<p>2018-11-08 学习日记</p><a id="more"></a><p>一天结束了，今天晚上有一个小时没学习，也没去做别的。。。。让我想起了三天打鱼两天晒网这几个字。</p><p>今天晚上在研究ActiveMQ，真写起代码来发现没有想象中的那么困难，但是要研究透还是要花费时间呀。</p><p>开始看gradle，发现可以挑着看，不需要所有的都看，突然发现自己看英文文档还是可以的，虽然还有部分单词不会，但只需要给足够的耐心还是可以看下去的，要耐心不能浮躁！</p><p>设计模式在今天看到六分之一了，可喜可贺，但是在今晚的ActiveMQ中，发现用了工厂模式，但是分不清是工厂模式还是抽象工厂模式，看来还没学到家呢！</p><p>明天继续加油，不能随意放弃！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018-11-08 学习日记&lt;/p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://blog.yilinfeng.top/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="日记" scheme="http://blog.yilinfeng.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2018-11-07 学习日记</title>
    <link href="http://blog.yilinfeng.top/%E6%97%A5%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/20181107%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0.html"/>
    <id>http://blog.yilinfeng.top/日记/学习日记/20181107学习日记.html</id>
    <published>2018-11-07T15:25:13.000Z</published>
    <updated>2019-03-10T05:19:27.031Z</updated>
    
    <content type="html"><![CDATA[<p>2018-11-07 学习日记</p><a id="more"></a><p>今天写日记才发现前天的日记没有提交到github，然后昨天偷懒了没有写到日记，今天早上也没有学习设计模式-_-</p><p>今天把k8s的文章看了一遍，但也只是算粗略的看了一下而已，距离应用还有很远呢，然后开始看gradle了，对比ActiveMQ，官网的文章还是挺不错的，起码知道怎么看。</p><p>与maven对比，ActiveMQ也是同样很难在网上找到合适的书籍来学习呢，可能大概都是工具的原因，gradle也差不多，也只能看官网了。ActiveMQ只能看博客来学了，幸好今天找到一篇比较好的博客。</p><p>然后接下来学zookeeper、kafka，接着学习spring cloud，看来距离第一阶段的目标还远着呢。</p><p>加油，不天不能再偷懒了！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018-11-07 学习日记&lt;/p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://blog.yilinfeng.top/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="日记" scheme="http://blog.yilinfeng.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2018-11-05 学习日记</title>
    <link href="http://blog.yilinfeng.top/%E6%97%A5%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/20181105%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0.html"/>
    <id>http://blog.yilinfeng.top/日记/学习日记/20181105学习日记.html</id>
    <published>2018-11-05T15:31:19.000Z</published>
    <updated>2019-03-10T05:19:27.031Z</updated>
    
    <content type="html"><![CDATA[<p>2018-11-05 学习日记</p><a id="more"></a><p>又过了一天了，今晚还以为没劲写这篇日记了，最后还是鼓起劲来写了，要坚持！</p><p>今天早上继续学习设计模式，学习到的简单工厂模式，想起在之前的工作中遇到过呢，然后才刚开始接触工厂模式，然后就要上班了。</p><p>今天晚上并没有学习啥，想学习activemq可是感觉又没有什么好的教材呢，官网的文档也还没研究透，究竟要怎么看这个官网呢，折腾路由器去了。。。。</p><p>今天在地铁上也没怎么看容器呢，时间都在发呆去了。</p><p>这样一想一天的学习时间可能就4个小时了，真的是浪费一点就少一点呀，要好好珍惜！</p><p>明天继续加油！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018-11-05 学习日记&lt;/p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://blog.yilinfeng.top/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="日记" scheme="http://blog.yilinfeng.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2018-11-04 学习日记</title>
    <link href="http://blog.yilinfeng.top/%E6%97%A5%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/20181104%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0.html"/>
    <id>http://blog.yilinfeng.top/日记/学习日记/20181104学习日记.html</id>
    <published>2018-11-04T15:26:54.000Z</published>
    <updated>2019-03-10T05:19:27.031Z</updated>
    
    <content type="html"><![CDATA[<p>深圳 周末2018-11-04 学习日记</p><a id="more"></a><p>今天是周日了，然后前天和昨天没有写到日记，坚持比想象要困难好多呀。</p><p>然后单例模式的问题依然还没解决，spring cloud的消息总线还没开始，貌似需要消息队列来配合，然后明天开始学习消息队列，然后继续完成spring cloud。</p><p>关于容易部分，看了好多，现在是到自己实践的时候了，k8s现在还在模式，在逐步搭建环境中，大概spring cloud学完的时候k8s也能用用了。</p><p>关于项目提交，今天想了一下，以后大概是以一天为周期每天提交项目了，可以提github刷刷推送，同时也能看到自己今天写了啥。</p><p>明天也要继续努力，加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深圳 周末2018-11-04 学习日记&lt;/p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://blog.yilinfeng.top/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="日记" scheme="http://blog.yilinfeng.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2018-11-01 学习日记</title>
    <link href="http://blog.yilinfeng.top/%E6%97%A5%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/20181101%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0.html"/>
    <id>http://blog.yilinfeng.top/日记/学习日记/20181101学习日记.html</id>
    <published>2018-11-01T15:30:37.000Z</published>
    <updated>2019-03-10T05:19:27.031Z</updated>
    
    <content type="html"><![CDATA[<p>2018-11-01 学习日记</p><a id="more"></a><p>前言：从今天开始！每天都在学习但是缺不知道自己的进度，所以我想每天花5分钟记录下今天的学习以及体会应该会有不一样的体验。</p><p>今天天气还可以，就是对我来说有点小冷。</p><p>早上起床时间比昨天早了5分钟，大概算是一种进步吧。</p><p>早上继续学习单例模式，明确了有5种写法，也知道了原来克隆、序列化、反射会破坏序列化，虽然一般不会有人这么做……，明天继续研究。</p><p>空闲时间继续看容器，中午跳的有点快，但是感觉用不上呀。不过到了编排部分又能静下心来看了，后面还有80章左右呢，加油！</p><p>明天继续努力！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018-11-01 学习日记&lt;/p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://blog.yilinfeng.top/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="日记" scheme="http://blog.yilinfeng.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot之devtools模块</title>
    <link href="http://blog.yilinfeng.top/java/SpringBoot%E4%B9%8Bdevtools%E6%A8%A1%E5%9D%97.html"/>
    <id>http://blog.yilinfeng.top/java/SpringBoot之devtools模块.html</id>
    <published>2018-04-01T15:43:10.000Z</published>
    <updated>2019-03-10T05:19:27.031Z</updated>
    
    <content type="html"><![CDATA[<p>为了方便项目的开发，spring boot提供了一个相应的开发者工具：spring-boot-devtools模块，通过使用该模块就能获得相应的开发时特性。本文章讲述的就是如何配置相关的特性。</p><a id="more"></a><p>spring-boot-devtools模块，提供了一系列开发时特性，包括：热部署、livereload等。合理的使用这些特性能有助于项目的开发。</p><h1 id="引入devtools模块"><a href="#引入devtools模块" class="headerlink" title="引入devtools模块"></a>引入devtools模块</h1><p>在项目中加入devtools模块很简单，只要在构建工具中引入相应的包即可。</p><p>值得一提的是：在Maven中将devtools依赖标记为optional，在Gradle中使用compileOnly来引用devtools依赖，是一个很好的习惯，可以有效的阻止devtools模块传递并应用到引用了该项目的项目。</p><h2 id="Gradle配置"><a href="#Gradle配置" class="headerlink" title="Gradle配置"></a>Gradle配置</h2><p>gradle的配置如下所示，值得注意的是下面并没有加入版本号，这是因为使用了io.spring.dependency-managent插件，从而省略了版本号。如果没有使用该插件就需要明确的标识出版本号。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">'org.springframework.boot:spring-boot-devtools'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h2><p>maven的配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><p>在运行一个完整打包的项目时devtools会被<strong>自动禁用</strong>。</p><p>默认情况下，打包好的jar、war是不包含devtools模块的，如果需要在已打包好的jar、war使用相关的开发特性，就需要在构建工具中，显式地配置excledeDevtools属性，让构建工具在打包时不要排除devtools模块。</p><h1 id="开发时特性"><a href="#开发时特性" class="headerlink" title="开发时特性"></a>开发时特性</h1><h2 id="自动重启"><a href="#自动重启" class="headerlink" title="自动重启"></a>自动重启</h2><p>当类路径上的文件发生变化时将会触发应用程序的自动重启，而无需自己手动重启项目，但是会自动忽略项目名为spring-boot、spring-boot-devtools、 spring-boot-autoconfigure、spring-boot-actuator和 spring-boot-starter的项目，即以上项目的改变不会触发重启。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Spring Boot提供的重启技术通过使用两个类加载器来工作，一个基类加载器用于加载不会改变的资源（例：第三方jar包），一个重启类加载器用于加载正在开发的类，当重启时仅重新创建重启类加载器的实例，从而实现更快的重启速度。</p><h3 id="资源钩子shutdown-hook"><a href="#资源钩子shutdown-hook" class="headerlink" title="资源钩子shutdown hook"></a>资源钩子shutdown hook</h3><p>devtools是依靠应用程序上下文的资源钩子（shutdown hook）在重启期间关闭它，如果禁用了资源钩子将会使得devtools无法正常工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication.setRegisterShutdownHook(<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure><h3 id="排除资源"><a href="#排除资源" class="headerlink" title="排除资源"></a>排除资源</h3><p>某些资源的改变是无需触发重启的。默认情况下，改变的资源在以下路径中：/META-INF/maven, /META-INF/resources, /resources, /static, /public, /templates都不会触发重启而是会触发实时重新加载。当然我们也可以自定义排除的资源，只要修改<em>spring.devtools.restart.exclude</em>属性，例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.devtools.restart.exclude=static/**,public/**</span><br></pre></td></tr></table></figure><p>但是以上写法会覆盖默认值，所以如果在不想覆盖默认值的情况下加入自定义的排除资源，需要使用<em>spring.devtools.restart.additional-exclude</em>属性，例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.devtools.restart.additional-exclude=static/**,public/**</span><br></pre></td></tr></table></figure><h3 id="监控其它路径"><a href="#监控其它路径" class="headerlink" title="监控其它路径"></a>监控其它路径</h3><p>默认的是只有类路径下的文件发生了改变才会触发重启，如果想要不在类路径下的资源发生改变后触发重启，需要使用<em>spring.devtools.restart.additional-paths</em>属性来配置额外的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.devtools.restart.additional-paths = other-path/**</span><br></pre></td></tr></table></figure><h3 id="关闭自动重启"><a href="#关闭自动重启" class="headerlink" title="关闭自动重启"></a>关闭自动重启</h3><p>如果不需要使用自动重启，可以通过禁用spring.devtools.restart.enabled属性来关闭该特性（注：重启类加载器依然会被初始化，但是不会监控文件的改变）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.devtools.restart.enabled = false</span><br></pre></td></tr></table></figure><p>如果想要彻底关闭devtools对于重启的支持，需要在调用SpringApplication.run()前，禁用<em>spring.devtools.restart.enabled</em>属性，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  System.setProperty(<span class="string">"spring.devtools.restart.enabled"</span>, <span class="string">"false"</span>);</span><br><span class="line">  SpringApplication.run(MyApp.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LiveReload"><a href="#LiveReload" class="headerlink" title="LiveReload"></a>LiveReload</h2><p>spring-boot-devtools包含了一个嵌入式的LiveReload服务器，允许当资源发生改变时实时刷新浏览器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.devtools.livereload.enabled=true</span><br></pre></td></tr></table></figure><p>默认的，该特性是打开了的。如果想停用该特性，则设置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.devtools.livereload.enabled=false</span><br></pre></td></tr></table></figure><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>spring-boot-devtools模块的开发时特性并没有完整的出现在文章中，比如说远程支持，更换类加载器等，仅仅选取了平时可能会用到的特性进行记录。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.spring.io/spring-boot/docs/2.0.1.BUILD-SNAPSHOT/reference/htmlsingle/#using-boot-devtools" target="_blank" rel="noopener">Spring Boot官方文档 Developer Tools</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了方便项目的开发，spring boot提供了一个相应的开发者工具：spring-boot-devtools模块，通过使用该模块就能获得相应的开发时特性。本文章讲述的就是如何配置相关的特性。&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://blog.yilinfeng.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring" scheme="http://blog.yilinfeng.top/categories/%E6%A1%86%E6%9E%B6/spring/"/>
    
      <category term="spring boot" scheme="http://blog.yilinfeng.top/categories/%E6%A1%86%E6%9E%B6/spring/spring-boot/"/>
    
    
      <category term="spring" scheme="http://blog.yilinfeng.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之Gradle插件</title>
    <link href="http://blog.yilinfeng.top/java/SpringBoot%E4%B9%8BGradle%E6%8F%92%E4%BB%B6.html"/>
    <id>http://blog.yilinfeng.top/java/SpringBoot之Gradle插件.html</id>
    <published>2018-03-31T07:42:56.000Z</published>
    <updated>2019-03-10T05:19:27.031Z</updated>
    
    <content type="html"><![CDATA[<p>在Java生态中，常用Maven和Gradle来对项目进行生命周期的管理。在本篇文章中使用Gradle来对Spring Boot项目进行构建，并记录常用的插件：java、war、dependency-management。</p><a id="more"></a><h1 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h1><p>关于Gradle的介绍在此省略，想了解相关知识的读者请自行搜索。</p><h1 id="SpringBoot插件"><a href="#SpringBoot插件" class="headerlink" title="SpringBoot插件"></a>SpringBoot插件</h1><blockquote><p>Spring Boot的Gradle插件提供了Spring Boot在Gradle上的支持，允许打包可执行的Jar包、war归档文件、运行Spring Boot应用，以及使用<em>spring-boot-dependecies</em>提供的依赖管理。<strong>注意:使用Spring Boot的Gradle插件需要Gradle4.0或以上的版本</strong></p></blockquote><p>由官方译文可以知道，想要使用Gradle来方便管理Spring Boot项目，使用SpringBoot插件是一个极佳的选择。</p><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>在Gradle中想要使用SpringBoot插件，需要如下的4个步骤：</p><ol><li>配置下载插件的仓库地址：<a href="https://repo.spring.io/libs-snapshot" target="_blank" rel="noopener">https://repo.spring.io/libs-snapshot</a></li><li>在依赖中引入要使用的插件，即SpringBoot的Gradle插件spring-boot-gradel-plugin</li><li>指定插件的版本，最好与项目使用的Spring Boot版本一致。</li><li>应用插件</li></ol><p>整个基本配置如下所示：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springbootVersion = <span class="string">'2.0.1.BUILD-SNAPSHOT'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url <span class="string">'https://repo.spring.io/snapshot'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'https://repo.spring.io/milestone'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springbootVersion&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: <span class="string">'org.springframework.boot'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里应用Java插件或者war插件</span></span><br><span class="line">apply plugin: <span class="string">'java'</span></span><br><span class="line">apply plugin: <span class="string">'io.spring.dependency-management'</span></span><br></pre></td></tr></table></figure><p>通过上述配置，就能在整个项目中使用SpringBoot插件了。同时为了方便后续spring boot的版本更改，在配置中加入了自定义的变量<em>springbootVersion</em>，用于指代spring boot的版本。</p><p>注：在Gradle的字符串中使用变量，需要在双引号中使用（在单引号中会无法识别），并且要以<em>${变量名}</em>这种形式进行引用。</p><p>在Spring Boot项目中，除了springboot插件外，还需要Java插件或War插件，以及dependency-management插件，才能达到构建项目所需的最少插件。</p><h2 id="运行应用"><a href="#运行应用" class="headerlink" title="运行应用"></a>运行应用</h2><p>要在不创建归档文件（jar、war）的情况下运行应用程序，需要使用bootRun任务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle bootRun</span><br></pre></td></tr></table></figure><h3 id="配置主类"><a href="#配置主类" class="headerlink" title="配置主类"></a>配置主类</h3><p>通过配置主类可以指定应用的运行入口。</p><p>默认情况下，bootRun任务会自动通过寻找在任务类路径下的目录中的带有<em>public static void main(String[])</em>方法的类配置为主类（main class）。</p><p>当然，可以通过bootRun任务的main属性显式地配置主类：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bootRun &#123;</span><br><span class="line">  main = <span class="string">'com.example.ExampleApplication'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，可以使用Spring Boot DSL的mainClassName属性在项目范围内配置主类：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">springBoot &#123;</span><br><span class="line">  mainClassName =<span class="string">'com.example.ExampleApplication'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>当项目中应用io.spring.dependency-management插件时，Spring Boot的插件会自动从项目中正在使用的Spring Boot版本导入相应的spring-boot-dependencies bom。这为Maven用户提供了类似的依赖管理体验，可以像使用使用maven一样，自定义依赖的jar包版本、排除依赖等。</p><p>当然可以不使用io.spring.dependency-management插件，但是这会为项目的管理徒然增加难度。</p><h3 id="自定义版本号"><a href="#自定义版本号" class="headerlink" title="自定义版本号"></a>自定义版本号</h3><p>通过使用依赖管理插件，可以使用属性来控制依赖关系的版本，参考<a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-dependencies/pom.xml" target="_blank" rel="noopener">bom</a>，例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ext[<span class="string">'slf4j.version'</span>] = <span class="string">'1.7.20'</span></span><br></pre></td></tr></table></figure><blockquote><p>Spring Boot的每个发布版本都是针对特定的第三方依赖来进行设计和测试。覆盖版本可能会导致兼容性问题，应该要小心处理。</p></blockquote><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>单独的使用SpringBoot插件对项目几乎没有改变，但是当使用了某些插件时，SpringBoot插件会检测出该插件并对项目配置做出相应的改变。以下列出几个常用的插件：</p><h3 id="Java插件"><a href="#Java插件" class="headerlink" title="Java插件"></a>Java插件</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'java'</span></span><br></pre></td></tr></table></figure><p>当项目中使用了Java插件，Gradle会做出以下改变：</p><ol><li>创建一个名为bootJar的BootJar任务：为项目创建一个可执行的jar。该jar将包含项目目录结构中main文件集中运行时类路径中的所有内容;类被放置在BOOT-INF / classes中，而jar被放置在BOOT-INF / lib中</li><li>将assemble任务配置为依赖于bootJar任务</li><li>禁用jar任务</li><li>创建了一个名为bootRun的BootRun任务，用于运行该项目</li><li>创建一个名为bootArchives的配置，其中包含由bootJar任务生成的组件</li><li>配置任何没有配置编码的JavaCompile任务以使用UTF-8编码</li><li>配置任何JavaCompile任务以使用-parameters编译器参数</li></ol><h3 id="War插件"><a href="#War插件" class="headerlink" title="War插件"></a>War插件</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'war'</span></span><br></pre></td></tr></table></figure><p>当项目中使用了war插件，Gradle会做出以下改变：</p><ol><li>创建一个名为bootWar的BootWar任务，该任务将为该项目创建一个可执行的war。除了标准打包之外，providedRuntime配置中的所有内容都将打包在WEB-INF/lib-provided的文件夹中</li><li>将assemble任务配置为依赖于bootWar任务</li><li>禁用war任务</li><li>配置bootArchives的配置以包含由bootWar任务生成的组件</li></ol><p>注意：使用了war插件就不需要再使用Java插件了。</p><h3 id="dependency-management插件"><a href="#dependency-management插件" class="headerlink" title="dependency-management插件"></a>dependency-management插件</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'io.spring.dependency-management'</span></span><br></pre></td></tr></table></figure><p>当项目应用<em>io.spring.dependency-management</em>插件时，SpringBoot插件将会自动从项目中正在使用的Spring Boot版本中导入spring-boot-dependencies bom。为Maven用户提供了类似的依赖管理体验。</p><p>注意：当使用了该插件时，可以在引用spring-boot-starter-**项目时省略相应的版本号，默认使用与项目一致的版本号。</p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>SpringBoot插件可以创建可执行的归档文件（jar、war），其中包含了一个应用所需的全部依赖，并且能够使用<em>java -jar</em>命令来运行。</p><h3 id="打包可执行的jar"><a href="#打包可执行的jar" class="headerlink" title="打包可执行的jar"></a>打包可执行的jar</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle bootJar</span><br></pre></td></tr></table></figure><p>可执行jar可以使用bootJar任务来构建。该任务在应用java插件时自动创建，并且是BootJar的一个实例。assemble任务自动配置为依赖于bootJar任务，因此运行assemble（或built）也将运行bootJar任务</p><h3 id="打包可执行的war"><a href="#打包可执行的war" class="headerlink" title="打包可执行的war"></a>打包可执行的war</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle bootWar</span><br></pre></td></tr></table></figure><p>可执行war可以使用bootWar任务来构建。该任务在应用war插件时自动创建，并且是BootWar的一个实例。assemble任务自动配置为依赖于bootWar任务，因此运行assemble（或built）也将运行bootWar任务</p><p>一个war文件可以被打包，以便它可以使用java -jar执行并被部署到一个外部容器。为此，应该将嵌入式servlet容器依赖项添加到providedRuntime配置中，列如：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compile <span class="string">'org.springframework.boot:spring-boot-starter-web'</span></span><br><span class="line">  providedRuntime <span class="string">'org.springframework.boot:spring-boot-starter-tomcat'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可以确保它们被封装在war文件的WEB-INF/lib提供的目录中，在哪里它们不会与外部容器的类冲突</p><h3 id="同时打包可执行的和常规的归档文件"><a href="#同时打包可执行的和常规的归档文件" class="headerlink" title="同时打包可执行的和常规的归档文件"></a>同时打包可执行的和常规的归档文件</h3><p>默认情况下，当配置bootJar或bootWar任务时，jar或war任务被禁用。通过启用jar或war任务，可以将项目配置为同时构建可执行归档文件和常规归档文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">  enabled = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为避免可执行文件和常规归档被写入同一位置，应将其中一个或另一个配置为使用不同的位置。其中一种方式是通过配置分类器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bootJar &#123;</span><br><span class="line">  classifier = &apos;boot&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排除Devtools"><a href="#排除Devtools" class="headerlink" title="排除Devtools"></a>排除Devtools</h3><p>默认情况下，Spring Boot的Devtools模块org.springframework.boot：spring-boot-devtools将被排除在可执行jar或war之外。如果您想在您的归档文件中包含Devtools，可以将将excludeDevtools属性设置为false，例子如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bootWar &#123;</span><br><span class="line">  excludeDevtools = <span class="keyword">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置需要解包的库"><a href="#配置需要解包的库" class="headerlink" title="配置需要解包的库"></a>配置需要解包的库</h3><p>当嵌套在可执行归档文件中时，大多数库可以直接使用，但某些库可能有问题。要处理任何有问题的库，可配置为在运行可执行归档文件时将特定的嵌套jar包解压到临时文件夹，可以将库标识为需要使用与源代码文件的绝对路径相匹配的Ant样式模式进行解包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bootJar &#123;</span><br><span class="line">  requiresUnpack &apos;**/jruby-complete-*.jar&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更多的控制，也可以使用闭合。闭包传递一个FileTreeElement，并返回一个布尔值，指示是否需要拆箱</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>本文大部分内容都摘录自官方文档，但通过阅读文档依然收获良多，并记录下自己常用或者可能会用到的知识点。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.spring.io/spring-boot/docs/2.0.1.BUILD-SNAPSHOT/gradle-plugin/reference/html/" target="_blank" rel="noopener">Spring Boot的Gradle插件</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java生态中，常用Maven和Gradle来对项目进行生命周期的管理。在本篇文章中使用Gradle来对Spring Boot项目进行构建，并记录常用的插件：java、war、dependency-management。&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://blog.yilinfeng.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring" scheme="http://blog.yilinfeng.top/categories/%E6%A1%86%E6%9E%B6/spring/"/>
    
      <category term="spring boot" scheme="http://blog.yilinfeng.top/categories/%E6%A1%86%E6%9E%B6/spring/spring-boot/"/>
    
    
      <category term="spring" scheme="http://blog.yilinfeng.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建</title>
    <link href="http://blog.yilinfeng.top/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html"/>
    <id>http://blog.yilinfeng.top/Hexo博客搭建.html</id>
    <published>2018-03-04T15:08:15.000Z</published>
    <updated>2019-03-10T05:19:27.031Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要讲述的是搭建<strong>Hexo + Github Page + Travis CI</strong>的博客环境。</p><p>目前有许多搭建个人博客的方案，但是使用Github Page来展示自己的个人博客，无疑是一个较好的方案，无需额外的服务器、免费、自带CDN、可靠并且自带网站域名，这种种的优势足以让人做出选择，然后加上美观的主题，就可以搭建出一个完整的博客系统了，当然要是有点懒的话，加上Travis CI进行自动部署，就可以专注于博客文章的编写了。</p><a id="more"></a><p><em>开始前的题外话：在这里我已假设你拥有git的使用知识。</em></p><h1 id="GitHub配置"><a href="#GitHub配置" class="headerlink" title="GitHub配置"></a>GitHub配置</h1><blockquote><p><a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a>主要是用于个人、组织、或者项目的网站，直接把网站代码托管在GitHub仓库上，别人就能访问到该网站，你只需要编辑并推送代码，你对网站的修改就能生效。<br><em>注意:GitHub Pages仅支持静态网站。</em></p></blockquote><h2 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h2><p>使用<strong>GitHub Pages</strong>来部署博客代码，需用到GitHub仓库，因而拥有一个GitHub的账号是必须的。<a href="https://github.com/join" target="_blank" rel="noopener">&gt;&gt;&gt;传送门&lt;&lt;&lt;</a></p><h2 id="创建博客代码仓库"><a href="#创建博客代码仓库" class="headerlink" title="创建博客代码仓库"></a>创建博客代码仓库</h2><p>根据GitHub Pages的官网介绍，GitHub Pages主要用于个人网站、组织网站和项目网站，它们的配置如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">网站类型</th><th style="text-align:left">网站域名与仓库名</th><th style="text-align:left">分支名</th></tr></thead><tbody><tr><td style="text-align:left">个人网站</td><td style="text-align:left">username.github.io</td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">组织网站</td><td style="text-align:left">orgname.github.io</td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">个人所拥有的项目</td><td style="text-align:left">username.github.io/projectname</td><td style="text-align:left">master、gh-pages或者master分支下的docs文件夹下</td></tr><tr><td style="text-align:left">组织所拥有的项目</td><td style="text-align:left">orgname.github.io/projectname</td><td style="text-align:left">master、gh-pages或者master分支下的docs文件夹下</td></tr></tbody></table></div><p>由上面的表格可以看到，对不同类型的网站，在仓库的命名和推送的目标分支仅有略微的差别，而对于要搭建个人博客的我们，关注点就在<strong>第一行</strong>上<em>（当然，聪明的你完全可以依照本篇文章的方法为自己的项目搭建一个网站出来）</em>。</p><p>参照上面的配置表格，根据自己GitHub上的用户名<em>username</em>，创建一个仓库并命名为：<strong>username.github.io</strong><br>与此同时，你的个人网站也拥有了相应的域名也就是仓库名<em>username.github.io</em>，以后你或者其他人就能通过该域名访问到你的网站。</p><h2 id="master分支与hexo分支"><a href="#master分支与hexo分支" class="headerlink" title="master分支与hexo分支"></a>master分支与hexo分支</h2><p>由上面的表格可以了解到，对于个人网站而言，网站代码必须存放于master分支上，GitHub Pages才能生效，而对于我们生成博客网站前的博客代码，我则存放于hexo分支上（读者可以放到其它地方或者其它分支上，只要最后博客网站代码正确推送到username.github.io仓库的master分支上即可）。<br><strong>master分支：存放最终生成的博客网站代码；</strong><br><strong>hexo分支：存放博客源代码；</strong></p><h1 id="博客配置"><a href="#博客配置" class="headerlink" title="博客配置"></a>博客配置</h1><p>在这里我选择了Hexo做为博客框架，当然如果感兴趣的读者也可以研究一下其它的博客框架。</p><h2 id="Hexo博客框架"><a href="#Hexo博客框架" class="headerlink" title="Hexo博客框架"></a>Hexo博客框架</h2><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p>Hexo博客框架依赖于node.js来运行并生成静态页面。</p><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>在这里建议下载稳定版LTS（<a href="https://nodejs.org/en/" target="_blank" rel="noopener">&gt;&gt;&gt;下载传送门&lt;&lt;&lt;</a>），以提供一个相对稳定的博客编写环境。下载并安装后，打开命令行界面，输入命令<em>node -v</em>，如果安装成功将会返回版本信息，如下图所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">8.9.4</span><br></pre></td></tr></table></figure><h3 id="安装Hexo博客框架"><a href="#安装Hexo博客框架" class="headerlink" title="安装Hexo博客框架"></a>安装Hexo博客框架</h3><p>打开命令行界面，输入如下命令，安装全局的Hexo命令，方便后续的博客编写操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>然后输入如下命令，安装hexo博客框架代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init 这里写存放博客代码的路径</span><br></pre></td></tr></table></figure><p>进入博客代码文件夹内，安装Hexo博客框架运行所需的依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>至此一个可运行的Hexo博客框架就搭建完成了，如果需要了解更多关于Hexo的使用方法，可点击<a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="noopener">&gt;&gt;这里&lt;&lt;</a>。</p><h2 id="Next博客主题"><a href="#Next博客主题" class="headerlink" title="Next博客主题"></a>Next博客主题</h2><p>博客主题对于博客来说是极其重要的，在这里我选择了使用Next主题，Next主题拥有众多的开发者，也被众多的博客所使用，因而能够保持着足够的活力，同时也能够在遇到问题的时候寻求到帮助。</p><p>为了方便余下篇幅的描述，作出以下约定：</p><ol><li>站点配置文件：Hexo博客根目录下一个名为<em>_config.yml</em>的文件，里面存放着整个博客站点的配置信息；</li><li>主题配置文件：在Hexo博客所引用的主题文件里也存在着一个名为<em>_config.yml</em>的文件，但与站点配置文件不同的是里面存放的是该主题的配置信息；</li><li>主题文件夹：Hexo博客根目录下有一个thems文件夹，里面存放着博客的主题资源；</li></ol><h3 id="主题安装基本步骤"><a href="#主题安装基本步骤" class="headerlink" title="主题安装基本步骤"></a>主题安装基本步骤</h3><h4 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h4><p>关于主题的具体下载方式，在这里暂且跳过，后续由专门的章节来进行讲解。<br>在这里假设我们已经下载好主题文件，并把主题文件夹命名为<em>next</em>（这里你可以命名为任何合法的名字，只需要在下一个步骤里填入相同的名字就可以了），把主题文件放置在<em>主题文件夹</em>内。</p><h4 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h4><p>Hexo博客在博客创建的时候就已经自带了一个主题，而要切换为自带的博客主题，就需要修改<em>站点配置文件</em>，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure><p>到这里博客就能够使用新的博客主题了。</p><h3 id="主题下载方式"><a href="#主题下载方式" class="headerlink" title="主题下载方式"></a>主题下载方式</h3><p>主题的下载方式决定了后续过程中对该主题进行个性化定制后升级的难易程度。</p><h4 id="直接下载"><a href="#直接下载" class="headerlink" title="直接下载"></a>直接下载</h4><p>直接下载，顾名思义就是直接下载整个主题，使用这种方式有一个弊端：在主题升级或者修复bug之后，主题的升级都需要去主题站点重新下载整个主题并替换掉旧的主题，费时费力；其次对于高度个性化定制主题之后，更是难以进行升级操作。因而<strong>强烈不推荐这种方式</strong>。</p><h4 id="git-clone下载"><a href="#git-clone下载" class="headerlink" title="git clone下载"></a>git clone下载</h4><p>使用<em>git clone</em>方式下载主题至主题文件夹内，是主题发布方的推荐方式，该种方式能够及时且方便的获取主题的最新版本，并且能够在高度个性化定制主题后能够轻松的保留更改的同时升级主题。</p><p>主题下载：进入博客根目录，打开命令行界面（<em>注意路径为博客根目录</em>），执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure><p>执行结束后主题文件夹下就多了一个叫next的文件夹，同时里面也存放有主题相关的资源文件。</p><p>主题更新：进入Next主题文件夹，打开命令行界面（<em>注意路径为博客根目录</em>），执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>如果更新遇到问题，可以参考<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">&gt;&gt;&gt;这里&lt;&lt;&lt;</a></p><h4 id="git子模块下载"><a href="#git子模块下载" class="headerlink" title="git子模块下载"></a>git子模块下载</h4><p>使用<em>git submodule</em>方式下载主题，是无法对主题内容进行高度个性定制化的，仅仅能够在Next主题允许的范围内对主题进行个性定制，优点就是在保留一定程度的定制化的同时能够轻松对主题进行升级（比<em>git clone</em>方法还要方便）。</p><p>主题下载：进入博客根目录，打开命令行界面（<em>注意路径为博客根目录</em>），执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://github.com/theme-next/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure><p>执行结束后主题文件夹下就多了一个叫next的文件夹，同时里面也存放有主题相关的资源文件。</p><p>主题更新：进入博客根目录，打开命令行界面（<em>注意路径为博客根目录</em>），执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --remote</span><br></pre></td></tr></table></figure><p>使用该种方式对主题的定制化，是通过在站定配置文件追加<em>theme_config</em>字段实现的，只要是主题配置文件中存在的字段就能够在<em>theme_config</em>字段下使用(<em>注意缩进</em>)，并且作用到主题中。例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="comment"># 主题</span></span><br><span class="line"><span class="attr">  scheme:</span> <span class="string">Mist</span></span><br><span class="line">  <span class="comment"># 头像</span></span><br><span class="line"><span class="attr">  avatar:</span> <span class="string">/images/avatar.png</span></span><br><span class="line">  <span class="comment"># 菜单</span></span><br><span class="line"><span class="attr">  menu:</span></span><br><span class="line"><span class="attr">    home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line"><span class="attr">    tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">    categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line"><span class="attr">    archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br></pre></td></tr></table></figure><h3 id="数学公式渲染"><a href="#数学公式渲染" class="headerlink" title="数学公式渲染"></a>数学公式渲染</h3><p>写博客的过程中可能会遇到需要编写数学公式的情景，要是使用图片来代替的话就不太优雅了，这时候可以考虑使用数学渲染引擎来直接渲染出数学公式了，幸运的是Next主题已经替我们准备好了。Next主题提供了两个渲染引擎：mathjax和katex，mathjax渲染速度较慢，但是支持的范围较广，katex渲染速度快，但是支持的范围较窄，因此博主选择了mathjax，以下内容也以mathjax为例，如果有需要的读者可自行查询文档：<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/MATH.md" target="_blank" rel="noopener">katex安装</a></p><p>首先卸载hexo自带的渲染工具<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br></pre></td></tr></table></figure></p><p>然后安装新的渲染工具，根据官方文档说，mathjax只能在hexo-renderer-kramed和hexo-renderer-pandoc中二选一，在这里博主选择了hexo-renderer-kramed<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-renderer-kramed --save # or hexo-renderer-pandoc</span><br></pre></td></tr></table></figure></p><p>在站点配置文件中，写入如下配置<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme_config:</span></span><br><span class="line"><span class="attr">  math:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    engine:</span> <span class="string">mathjax</span></span><br><span class="line"><span class="attr">    mathjax:</span></span><br><span class="line"><span class="attr">      cdn:</span> <span class="string">//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure></p><p>即可使博客网站具备渲染数学公式的能力，更多的配置可在主题配置文件（Next/_config.yml）的math部分查看。</p><p>然后在需要进行数学公式渲染的markdown文件中，开头部分加入mathjax: true，即可让数学渲染引擎对该文件进行渲染，如果不需要进行数学渲染的切记不要添加，因为会有损性能。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>如果成功了的话，就能看到你现在所看到的数学公式了</p><script type="math/tex; mode=display">f(n) =\begin{cases}n/2,  & \text{if $n$ is even} \\3n+1, & \text{if $n$ is odd}\end{cases}</script><h1 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h1><p>一篇新的博客文章需要经历三个步骤才能出现在博客中：</p><ol><li>写文章</li><li>生成GitHub Pages用的博客代码（hexo generate）</li><li>提交上述的生成的博客代码（git push）</li></ol><p>要是每次写一遍新的文章都要经历如上三个步骤多繁琐呀！要是能把第二个步省略掉，自己只专注于写博客，然后提交新的文章，文章就能自动出现在博客中那该多好呀，使用Travis CI就能达到这个目的，替我们完成这与创作无关的步骤。</p><h2 id="GitHub权限配置"><a href="#GitHub权限配置" class="headerlink" title="GitHub权限配置"></a>GitHub权限配置</h2><p>使用Travis CI来自动部署网站代码，必须对代码仓库进行设置，同时需要授予Travis CI相应的权限，而GitHub已经提供了相应的开发者接口，并且有一套完善安全的接口调用方法。</p><h3 id="获取Access-Token"><a href="#获取Access-Token" class="headerlink" title="获取Access Token"></a>获取Access Token</h3><ol><li>登陆GitHub</li><li>进入个人设置页面（点击自己的头像图标-&gt;Settings）</li><li>点击左侧栏下的Developer settings（Personal settings-&gt;Developer settings）</li><li>点击Personal access tokens</li><li>这个时候就能看到如下图所示的界面，点击Generate new token按钮<img src="/images/blog/generatenewtoken.png" alt="Generate new token界面"></li><li>填写Token description（凭据描述,方便以后自己的辨别），选中repo下的publish_repo选项（授予Travis CI的权限），如下图所示：<img src="/images/blog/newpersonalaccesstoken.png" alt="New Personale Access Token">然后点击下方的Generate token（保存设置）</li><li>点击保存后回到步骤5的界面，这时候会显示一串字符，这就是Travis CI所需要的凭据<strong>（注意：立刻保存好这串字符，因为该字符串仅在第一次显示，并且为了自己的代码安全不要告诉他人这串字符的任何信息）</strong><img src="/images/blog/accesstoken.png" alt="Access Token"></li></ol><h3 id="GitHub仓库配置"><a href="#GitHub仓库配置" class="headerlink" title="GitHub仓库配置"></a>GitHub仓库配置</h3><ol><li>登陆GitHub</li><li>进入<em>username.github.io</em>仓库</li><li>点击仓库上方的Settings按钮<img src="/images/blog/reposetting.png" alt="Settings"></li><li>点击左侧栏的Integrations &amp; services-&gt;点击右侧的Add services按钮-&gt;输入并选中Travis CI，如下图所示<img src="/images/blog/addservice.png" alt="Add Services"></li><li>点击下方的绿色Add service</li></ol><p>至此，在GitHub方面的配置就完成了。</p><h2 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h2><blockquote><p>Travis CI是一个提供持续集成的服务，能够与GitHub很好的结合起来。Travis CI对于GitHub的开源仓库是免费的，对于私有仓库是需要收费的。</p></blockquote><h3 id="Travis-CI注册"><a href="#Travis-CI注册" class="headerlink" title="Travis CI注册"></a>Travis CI注册</h3><p>要使用Travis CI当然要先注册一个账号<a href="https://www.travis-ci.org/" target="_blank" rel="noopener">&gt;&gt;&gt;传送门&lt;&lt;&lt;</a>，而Travis CI允许使用GitHub的账号作为第三方授权登陆。</p><h3 id="Travis-CI配置"><a href="#Travis-CI配置" class="headerlink" title="Travis CI配置"></a>Travis CI配置</h3><p>当使用GiHub授权登陆Travis CI的时候，Travis CI就能感知到我们仓库的状态，这时候就要设置究竟是那个仓库要进行持续集成了。</p><ol><li>点击头像图标进入如下界面：<img src="/images/blog/tciselectrepo.png" alt="GitHub仓库列表"></li><li>选中username.github.io仓库（按钮变为绿色）</li><li>点击旁边的小齿轮，进入仓库的具体设置页面</li><li>点击右侧的more options-&gt;选择Settings<img src="/images/blog/tcisettingheader.png" alt="Travis CI Setting header"></li><li>按下图选中对应的选项<img src="/images/blog/tcisettingcontent.png" alt="Travis CI Setting Content"></li><li>在Environment Variables部分中，写入环境变量GITHUB_TOKEN，值为上述提到的Token，然后点击add按钮添加</li></ol><p>至此在Travis CI的配置就完成了。</p><h2 id="博客源代码配置"><a href="#博客源代码配置" class="headerlink" title="博客源代码配置"></a>博客源代码配置</h2><p>Travis CI服务的使用，除了需要在Travis CI和GitHub中进行配置外，还需要在博客根目录下添加一个名为.travis.yml的文件，这个配置文件告诉了Travis CI如何工作，配置文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo博客框架是依赖于node.js环境来运行的</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="comment"># 指定node.js的版本</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"><span class="comment"># 缓存依赖文件，提高构建的速度</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  directories:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"node_modules"</span></span><br><span class="line"><span class="comment"># 指定对什么分支才进行构建</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line">  <span class="comment"># 这里替换成自己的分支</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">your-github-branch</span></span><br><span class="line"><span class="comment"># 安装hexo所需要的依赖</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="comment"># 构建时执行的动作，这里是生成博客的网站代码</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"><span class="comment"># 推送网站代码到github</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  provider:</span> <span class="string">pages</span></span><br><span class="line"><span class="attr">  skip-cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 这里引用上一步中所填入的Token</span></span><br><span class="line"><span class="attr">  github-token:</span> <span class="string">$GITHUB_TOKEN</span></span><br><span class="line"><span class="attr">  keep-history:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 将要推送到github的代码位置，这里是指向Hexo生成的博客网站代码的文件夹</span></span><br><span class="line"><span class="attr">  local-dir:</span> <span class="string">./public</span></span><br><span class="line">  <span class="comment"># 推送的目标分支</span></span><br><span class="line"><span class="attr">  target-branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="comment"># 构建结果的通知对象</span></span><br><span class="line"><span class="attr">  email:</span> <span class="string">your-email</span></span><br><span class="line">  <span class="comment"># 提交者</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">commiter</span></span><br><span class="line">  <span class="comment"># 推送前的条件判断</span></span><br><span class="line"><span class="attr">  on:</span></span><br><span class="line">    <span class="comment"># 本次构建来自指定分支才进行推送，预防有多分支时造成的误推送（这里与前面都点重复）</span></span><br><span class="line"><span class="attr">    branch:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">your-github-branch</span></span><br><span class="line"><span class="comment"># 设置邮件通知，构建成功或失败都进行通知</span></span><br><span class="line"><span class="attr">notifications:</span></span><br><span class="line"><span class="attr">  email:</span></span><br><span class="line"><span class="attr">    on_success:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    on_failure:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><p>经过上述的三个配置步骤，博客的自动部署就设置完成了，现在我们写一篇博客文章只需要：</p><ol><li>写博客文章</li><li>推送文章内容到GitHub仓库</li></ol><p>然后剩下的就交给Travis CI来完成了，它将会代替我们生成网站代码并部署到GitHub仓库上，我们只要耐心的等待一下，就能在网站上看到效果了。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>网络上关于Hexo博客搭建的文章很多，如果有人能读到本篇文章，希望能给你带来一点帮助！</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://help.github.com/categories/github-pages-basics/" target="_blank" rel="noopener">GitHub Pages帮助文档</a><br><a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="noopener">Hexo帮助文档</a><br><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Next主题</a><br><a href="https://docs.travis-ci.com/" target="_blank" rel="noopener">Travis CI帮助文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要讲述的是搭建&lt;strong&gt;Hexo + Github Page + Travis CI&lt;/strong&gt;的博客环境。&lt;/p&gt;
&lt;p&gt;目前有许多搭建个人博客的方案，但是使用Github Page来展示自己的个人博客，无疑是一个较好的方案，无需额外的服务器、免费、自带CDN、可靠并且自带网站域名，这种种的优势足以让人做出选择，然后加上美观的主题，就可以搭建出一个完整的博客系统了，当然要是有点懒的话，加上Travis CI进行自动部署，就可以专注于博客文章的编写了。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://blog.yilinfeng.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://blog.yilinfeng.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>博客之始</title>
    <link href="http://blog.yilinfeng.top/%E6%97%A5%E8%AE%B0/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E5%A7%8B.html"/>
    <id>http://blog.yilinfeng.top/日记/博客之始.html</id>
    <published>2018-02-15T16:00:00.000Z</published>
    <updated>2019-03-10T05:19:27.031Z</updated>
    
    <content type="html"><![CDATA[<p>以前总是看别人写的博客，用OneNote做的笔记，当面试的时候被问到：你有写博客吗？我的回答是NO！  那时候以为写博客离自己很遥远，觉得自己的水平低写不出什么东西来，但是现在仔细想想，不正是因为自己的水平低才更要写博客吗！</p><p>通过写博客来做笔记并且加入自己的思考，摆脱以前一贯的只记忆不思考的习惯，一次又一次地修改完善，才能更好的提高自己的能力。</p><p>在这特殊的一天，踏出新的一步，祝2018年大家越来越好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以前总是看别人写的博客，用OneNote做的笔记，当面试的时候被问到：你有写博客吗？我的回答是NO！  那时候以为写博客离自己很遥远，觉得自己的水平低写不出什么东西来，但是现在仔细想想，不正是因为自己的水平低才更要写博客吗！&lt;/p&gt;
&lt;p&gt;通过写博客来做笔记并且加入自己的思
      
    
    </summary>
    
      <category term="日记" scheme="http://blog.yilinfeng.top/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="日记" scheme="http://blog.yilinfeng.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
</feed>
